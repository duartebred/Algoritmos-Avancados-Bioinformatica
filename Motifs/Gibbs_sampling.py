# w-> window size of the motif
# t -> size of each sequence, all sequences have the same length
# n -> number of sequences

seqs = ['GTAAACAATATTTATAGC', 'AAAATTTACCTTAGAAGG', 'CCGTACTGTCAAGCGTGG', 'TGAGTAAACGACGTCCCA', 'TACTTAACACCCTGTCAA']


# selecting randomly the initial position

class PWM:
    """
    This class stores all the functions needed to generate the position weight matrix of a list of sequences. It also includes the function 
    to calculate the probability of a sequence being generated by the PWM
    
    Parameters
    ------------
    seqs: list[str]
        The list of sequences used to generate the PWM
    
    seq_type: str
        The type of the biological sequences used to generate the PWM
        
    pseudo: int
        Value of pseudocount to prevent matrix entries to have value of 0
    
    """
    def __init__(self, seqs: list[str], seq_type: str = 'DNA', pseudo: int =1) -> None:
        self.seqs = seqs
        self.seq_type = seq_type
        self.pseudo = pseudo
        self.pwm = self.pwm()

    def alfabeto(self) -> str:
        """
        Returns the alphabet for the given sequence type

        Returns
        -------
        str
            Alphabet of the given sequence type
        
        Raises
        ------
        AssertionError
            If the sequence is not a valid biological sequence
            
        """
        valid_type = ['DNA', 'RNA', 'PROTEIN']

        assert isinstance(self.seq_type,str), 'The sequence type must be a string'
        assert self.seq_type.upper() in valid_type, f' The seq type {self.seq_type} is not a valid biological sequence'

        if self.seq_type.upper() == "DNA":
            return "ACGT"
        elif self.seq_type.upper() == "RNA":
            return "ACGU"
        else:
            return "ABCDEFGHIKLMNPQRSTVWYZ"


    def pwm(self) -> list[dict[str, float]]:
        """
        Genaretes a position weight matrix (PWM) from a list of aligned sequences
                
        Returns
        -------
        list[dict[str, float]]
            Probabillity of each letter in the alphabet being present in a specific position
        
        Raises
        ------
        AssertionError
            - If the sequences are not given in a list
            - If the lengrhs of at least one of the sequences differ from the rest
            - If at least one elemet of the sequences is not present in the alphabet
            
        """
        
        # Check if sequences are provided in a list
        assert isinstance(self.seqs, list), 'Sequences must be a list'

        # Check if all sequences have the same length
        assert all(len(self.seqs[0])==len(seq)for seq in self.seqs), 'As sequencias devem possuir o mesmo tamanho'
       
       # Obtain the alphabet
        alphabet = self.alfabeto()

        # Check if  each element in sequences is in the alphabet
        for seq in self.seqs:
            for pos, elem in enumerate(seq):
                assert elem in alphabet, f"The element '{elem}' at position {pos + 1} in sequence {seq} is not in the alphabet. Please ensure all elements are in uppercase."

        # Initializing list to store the resulting PWM
        resulting_pwm= []

        # Calculate frequencies for each position
        for coluna in list(zip(*self.seqs)):
            contagem = {elem:(coluna.count(elem) + self.pseudo) / (len(self.seqs) + len(alphabet) * self.pseudo) for elem in alphabet}
            resulting_pwm.append(contagem)
        return resulting_pwm
    

    def prob_seq(self, seq: str):
        """
        Esta função calcula a probabilidade de uma determinada sequencia ter sido gerada pela PWM

        Parameters
        ---------
        seq:str
            Sequência que se pretende calcular a probabilidade de ter sido gerada pela PWM

        Returns
        -------
        prod:float
            Probabilidade de a sequencia fornecida ter sido gerada pela PWM

        Raises
        ------
        AssertionError
            Quando o tamanho da sequência não é igual ao tamanho da PWM

        """
        assert len(seq) <= len(self.pwm), f"A sequência {seq} não é do mesmo tamanho que a PWM"

        prod = 1
        for I, elem in enumerate(seq):
            prod = prod * self.pwm[I][elem]
        return prod
    

class Gibbs (PWM):
    def __init__(self, list_seqs: list[str], w: int, seq_type='DNA', pseudo=1):
        self.seqs = list_seqs
        self.w = w
        self.seq_type = seq_type
        self.pseudo = pseudo
        
    
    def random_init_pos(self) -> list[int]:
        import random
        assert type(self.seqs) == list, 'As sequencias devem ser fornecidas em formato de lista'
        t = len(self.seqs[0])  # length of each seq
        n = len(self.seqs)  # number of seqs
        max_pos = t - self.w  # last possible position the use to form a seq with length w
        pos = [random.randint(0, max_pos) for _ in range(n)]  # choose random positions between 0 and max_pos

        return pos
    

    def random_seq(self) -> int:
        import random
        n = len(self.seqs)
        return random.randint(0, n - 1)
    

    def new_seqs(self, pos: list[int], seq_idx: int):
        assert type(pos) == list and type(seq_idx) == int
        novas_seqs = [self.seqs[idx][P:P + self.w] for idx, P in enumerate(pos) if idx != seq_idx]  # create the motifs with the size w
        return novas_seqs, self.seqs[seq_idx]
    
    

    def prob(self, pos: list[int], seq_idx: int, first=True):
        if first:
            possible_motiff, seq_excluded = self.new_seqs(pos, seq_idx)

        else:
            possible_motiff = [seq[pos[idx]: pos[idx] + self.w] for idx, seq in enumerate(self.seqs) if idx != seq_idx]
            seq_excluded = self.seqs[seq_idx]

        #super().__init__(possible_motiff, self.seq_type, self.pseudo)
        t = len(self.seqs[0])
        max_pos = t - self.w
        seqs_pwm = PWM(possible_motiff, self.seq_type, self.pseudo).pwm
        prob = []

        for I in range(max_pos + 1):
            seq = seq_excluded[I:I + self.w]
            prob.append(self.prob_seq(seq, seqs_pwm))

        return [prob[I] / sum(prob) for I in range(len(prob))]


    def roulette_wheel(self, probs: list[float]):
        import random
        assert (round(sum(probs), 0) == 1)
        pos = [I for I in range(len(probs))]

        return random.choices(pos, probs, k=1)


    def score(self, off: list[int]) -> int:
        alfa=self.alfabeto()
        snips = [self.seqs[I][p:p + self.w] for I, p in enumerate(off)]
        return sum(max({x: s.count(x) for x in alfa}.values()) for s in zip(*snips))


    def gibbs_sampling(self):
        pos = self.random_init_pos()
        first_run, max_sc, contador = True, 0, 0

        while True:
            seq_idx = self.random_seq()

            if first_run:
                probs, first_run = self.prob(pos, seq_idx), False
            
            else: probs = self.prob(pos, seq_idx, first=False)

            pos[seq_idx] = self.roulette_wheel(probs)[0]

            if self.score(pos) > max_sc:
                best_off, max_sc, contador = pos.copy(), self.score(pos), 0 

            else:
                contador += 1
                if contador >=50: break

        return best_off, max_sc
        





