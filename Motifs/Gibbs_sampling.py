# w-> window size of the motif
# t -> size of each sequence, all sequences have the same length
# n -> number of sequences

import subprocess; import random


class pwm:
    """
    This class stores all the functions needed to generate the position weight matrix of a list of sequences. It also includes the function 
    to calculate the probability of a sequence being generated by the PWM
    
    Parameters
    ------------
    seqs: list[str]
        A list of biological sequences. Default is None.
    
    seq_type: str
        The type of the biological sequences. Default is 'DNA'.
        
    pseudo: int
        The pseudo count value to prevent matrix entries from having a value of 0. Default is 1.
    
    """
    def __init__(self, seqs: list[str] =None, seq_type: str = 'DNA', pseudo: int =1) -> None:
        self.seqs = seqs
        self.seq_type = seq_type
        self.pseudo = pseudo


    def alfabeto(self) -> str:
        """
        Returns the alphabet for the given sequence type.

        Parameters
        ----------
        self : pwm
            An instance of the pwm class. Self.seq_type stores the type of the biological sequences.

        Returns
        -------
        str
            The alphabet of the given sequence type.

        Raises
        ------
        AssertionError
            If the sequence type is not a string.
            If the sequence type is not a valid biological sequence.

        """
        valid_type = ['DNA', 'RNA', 'PROTEIN']

        assert isinstance(self.seq_type,str), 'The sequence type must be a string'
        assert self.seq_type.upper() in valid_type, f' The seq type {self.seq_type} is not a valid biological sequence'

        if self.seq_type.upper() == "DNA":
            return "ACGT"
        elif self.seq_type.upper() == "RNA":
            return "ACGU"
        else:
            return "ABCDEFGHIKLMNPQRSTVWYZ"

    def generate_pwm(self) -> list[dict[str, float]]:
        """
            Generates a position weight matrix (PWM) from a list of aligned sequences.

            Parameters
            ----------
            self : pwm
                An instance of the pwm class.
                self.seqs : list[str]
                    A list of biological sequences.
                self.seq_type : str
                    The type of the biological sequences.
                self.pseudo : int
                    The pseudo count value to prevent matrix entries from having a value of 0.

            Returns
            -------
            list[dict[str, float]]
                Probability of each letter in the alphabet being present in a specific position.

            Raises
            ------
            AssertionError
                - If the sequences are not given in a list.
                - If the lengths of at least one of the sequences differ from the rest.
                - If at least one element of the sequences is not present in the alphabet.
        """
        # Check if sequences are provided in a list
        assert isinstance(self.seqs, list), 'Sequences must be a list'
        # Check if all sequences have the same length
        assert all(len(self.seqs[0])==len(seq)for seq in self.seqs), 'As sequencias devem possuir o mesmo tamanho'
        # Obtain the alphabet
        alphabet = self.alfabeto()
        # Check if  each element in sequences is in the alphabet
        for seq in self.seqs:
            for pos, elem in enumerate(seq):
                assert elem in alphabet, f"The element '{elem}' at position {pos + 1} in sequence {seq} is not in the alphabet of {self.seq_type}. Please ensure all elements are in uppercase."

        # Initializing list to store the resulting PWM
        resulting_pwm= []

        # Calculate frequencies for each position
        for coluna in list(zip(*self.seqs)):
            contagem = {elem:(coluna.count(elem) + self.pseudo) / (len(self.seqs) + len(alphabet) * self.pseudo) for elem in alphabet}
            resulting_pwm.append(contagem)
        return resulting_pwm
    
    def prob_seq(self, seq: str)->float:
        """
        Calculate the probability of a given sequence being generated by the PWM.
        The PWM is a statistical model used in bioinformatics to represent the probability of each nucleotide (or amino acid) at each position in a set of aligned sequences.

        Parameters:
        ----------
        seq : str
            The sequence for which the probability of generation by the PWM is to be calculated.

        Returns:
        -------
        float
            The probability of the given sequence being generated by the PWM.

        Raises:
        ------
        AssertionError
            If the length of the sequence is not equal to the length of the PWM.
        """
        pwm= self.generate_pwm()
        # Check if the length of the sequence is smaller or have the length of the PWM
        assert len(seq) <= len(pwm), f"The sequence '{seq}' is not the same length as the PWM"

        # Initialize product to store probability
        product = 1

        # Calculate the probability of the sequence
        for index, elem in enumerate(seq.upper()):
            product *= pwm[index][elem]
        
        return product
    

class Gibbs (pwm):
    """
    Initialize Gibbs sampler.

    Parameters:
    ----------
    list_seqs : list[str]
        List of input sequences. Each sequence should be a string.
    w : int
        Motif length. This is the length of the motif that will be searched in the sequences.
    seq_type : str, optional
        Biological type of sequences. Default is 'DNA'. This parameter is used to determine the 
        alphabet of the sequences.
    pseudo : int, optional
        Pseudo count for PWM (Position Weight Matrix). Default is 1. This parameter is used to 
        prevent matrix entries from having a value of 0.

    Returns:
    -------
    None
        This method initializes the Gibbs sampler with the provided parameters.
    """
    def __init__(self, list_seqs: list[str], w: int, seq_type='DNA', pseudo=1):

        self.seqs = list_seqs
        self.w = w
        self.seq_type = seq_type
        self.pseudo = pseudo


    def random_init_pos(self) -> list[int]:
        """
        Gives random positions to initialize motif search.

        Parameters:
        ----------
        self : Gibbs
            An instance of the Gibbs class. This instance contains the list of sequences, motif length, 
            biological sequence type, and pseudo count for PWM.

        Returns:
        -------
        list[int]
            A list of random initial positions. Each position represents the starting point of a motif 
            in a sequence. The length of the list is equal to the number of sequences.

        Raises:
        ------
        AssertionError
            If the sequences are not provided in a list. This is checked by verifying if the 'eqs' 
            attribute of the 'elf' instance is a list.

        Notes:
        ------
        The random positions are generated using the 'random.randint()' function from the 'random' 
        module. The maximum possible position for a motif of length 'w' in a sequence of length 't' is 
        calculated as 't - w'. The random positions are then stored in a list and returned.
        """
        import random

        # Check if sequences is a list
        assert isinstance(self.seqs,list), 'Sequences must be a list'

        # Get the length of each sequence and the total number of sequences
        t = len(self.seqs[0])  
        n = len(self.seqs)  

        # Calculate the maximum possible position to from a motif with length w
        max_pos = t - self.w 

        # Choose random positions between 0 and max_pos for each sequence
        positions = [random.randint(0, max_pos) for _ in range(n)]

        return positions
    

    def random_seq(self) -> int:
        """
        Generate a random integer representing the sequence index.
        The random sequence index is used to exclude one sequence during the motif search process.

        Parameters:
        ----------
        self : Gibbs
            An instance of the Gibbs class. This instance contains the list of sequences.

        Returns:
        -------
        int
            Randomly generated sequence index. The index is used to select a sequence from the list of sequences.

        Raises:
        ------
        AssertionError
            If the sequences are not provided in a list. This is checked by verifying if the 'eqs' attribute of the 'elf' instance is a list.

        Notes:
        ------
        The random sequence index is generated using the 'random.randint()' function from the 'random' module.
        The maximum possible index is calculated as 'n - 1', where 'n' is the number of sequences in the list.
        """
        # Check if sequences are in a list
        assert isinstance(self.seqs,list), 'Sequences must be provided in a list'
        
        # Get the number of sequences
        n = len(self.seqs)

        # Generate a random sequence index
        sequence_index = random.randint(0, n - 1)

        return sequence_index
    

    def new_seqs(self, pos: list[int], seq_idx: int) -> tuple[list[str], str]:
        """
        Generate subsequences of length w based on given positions excluding one of the sequences.

        Parameters
        ----------
        pos : list[int]
            List of positions where to start making the motif for each sequence.
            Each position is an integer representing the starting point of a motif in a sequence.

        seq_idx : int
            Index of the sequence to be excluded.
            The index is an integer representing the position of the sequence in the list of sequences.

        Returns
        ---------
        tuple[list[str], str]
            A tuple containing two elements:
            1. A list of subsequences (motifs) of length 'w' from the sequences, excluding the sequence at 'eq_idx'.
            2. The excluded sequence.

        Raises
        ------------
        AssertionError:
            If the positions are not provided in a list.
            If the index of the sequence to be excluded is not an integer.
            If the list of positions for each sequence does not have the same length as the number of sequences.

        """
        assert isinstance(pos,list) and isinstance(seq_idx,int)
        assert len(pos)==len(self.seqs), f"The number of positions should be equal to the number of sequences, you have {len(pos)} positions and {len(self.seqs)} sequences"

        novas_seqs = [self.seqs[idx][P:P + self.w] for idx, P in enumerate(pos) if idx != seq_idx]  # create the motifs with the size w
        return novas_seqs, self.seqs[seq_idx]
    
    def prob_each_seq(self, pos: list[int], seq_idx: int, first=True):
        """
        Calculate probabilities of each position for a sequence.

        Parameters:
        ----------
        pos : list[int]
            List of positions. Each position is an integer representing the starting point of a motif in a sequence.

        seq_idx : int
            Index of the sequence. The index is an integer representing the position of the sequence in the list of sequences.

        first : bool, optional
            Boolean flag to indicate if it's the first run (default is True). This flag is used to determine whether to generate new motifs and exclude a sequence.

        Returns:
        -------
        list[float]
            List of probabilities. Each probability represents the likelihood of a position being the starting point of a motif in the sequence.

        Notes:
        ------
        - If 'first' is True, the method generates new motifs by excluding the sequence at 'eq_idx' and calculates the probabilities for each position in the excluded sequence.
        - If 'first' is False, the method reuses the existing motifs and calculates the probabilities for each position in the sequence at 'eq_idx'.
        - The probabilities are normalized by dividing each probability by the sum of all probabilities.
        """
        if first:
            possible_motiff, seq_excluded = self.new_seqs(pos, seq_idx)

        else:
            possible_motiff = [seq[pos[idx]: pos[idx] + self.w] for idx, seq in enumerate(self.seqs) if idx != seq_idx]
            seq_excluded = self.seqs[seq_idx]

        t = len(self.seqs[0])
        max_pos = t - self.w
        #seqs_pwm = pwm(seqs=possible_motiff, seq_type=self.seq_type, pseudo=self.pseudo).generate_pwm()
        prob = []

        for I in range(max_pos + 1):
            seq = seq_excluded[I:I + self.w]
            #prob.append(self.prob_seq(seq, seqs_pwm))
            prob.append(pwm(seqs=possible_motiff, seq_type=self.seq_type, pseudo=self.pseudo).prob_seq(seq))
            

        return [prob[I] / sum(prob) for I in range(len(prob))]

    def roulette_wheel(self, probs: list[float]):
        """
        Randomly selects a sequence based on probabilities.

        Parameters
        -----------
        probs : list[float]
            List of probabilities for each index. The sum of all probabilities should be 1.

        Returns
        ----------
        int
            The selected index. The index is chosen based on the probabilities provided.

        Raises
        ----------
        AssertionError
            If the sum of the list of probabilities is not 1. This is to ensure that the probabilities 
            represent a valid probability distribution.

        Notes
        ----------
        This function uses the 'random.choices()' function from the 'random' module to perform the 
        roulette wheel selection. The 'choices()' function takes three parameters: a list of items to choose 
        from, a list of corresponding weights (in this case, the probabilities), and the number of items to 
        choose. In this case, we choose only one item, so 'k' is set to 1.

        The 'random.choices()' function returns a list of chosen items. Since we are only choosing one 
        item, we take the first element of the returned list using '[0]'.

        The 'pos' list is created using a list comprehension to generate a list of indices from 0 to the 
        length of the 'probs' list. This 'pos' list is used as the items to choose from in the 
        'random.choices()' function.

        The 'probs' list is passed as the weights to the 'random.choices()' function. This ensures that 
        the items with higher probabilities are more likely to be chosen.
        """
        import random
        assert (round(sum(probs), 0) == 1)
        pos = [I for I in range(len(probs))]

        return random.choices(pos, probs, k=1)

    def score(self, off: list[int]) -> int:
        """
        Calculates the score of the current motif positions.

        The score is calculated as the sum of the maximum counts of each nucleotide (or amino acid) 
        in each column of the motifs. This score represents the overall similarity of the motifs.

        Parameters:
        ----------
        off : list[int]
            A list of integers representing the current positions of the motifs in the sequences.
            Each integer is the starting position of a motif in a sequence.

        Returns:
        -------
        int
            The score of the current motif positions. The score is an integer representing the 
            overall similarity of the motifs.

        """
        alfa=self.alfabeto()
        snips = [self.seqs[I][p:p + self.w] for I, p in enumerate(off)]
        return sum(max({x: s.count(x) for x in alfa}.values()) for s in zip(*snips))

    def gibbs_sampling(self)-> tuple[list[int], int]:
        """
        Performs Gibbs sampling to find the most likely motif positions in a set of sequences.

        Parameters:
        ----------
        self : Gibbs
            An instance of the Gibbs class. This instance contains the list of sequences, motif length, 
            biological sequence type, and pseudo count for PWM.

        Returns:
        -------
        tuple[list[int], int]
            A tuple containing two elements:
            1. A list of the most likely motif positions in the sequences.
            2. The score of the most likely motif positions.

        Notes:
        ------
        - The Gibbs sampling algorithm is an iterative process that uses a randomized approach to find the 
        most likely motif positions in a set of sequences.
        - The algorithm starts by initializing random motif positions in the sequences.
        - In each iteration, the algorithm selects a random sequence and updates the position of the motif 
        in that sequence based on the probabilities calculated using the PWM.
        - The algorithm continues this process until a maximum number of iterations is reached or the 
        score of the motif positions does not improve for a certain number of iterations.
        - The algorithm returns the most likely motif positions and their score.
        """

        pos = self.random_init_pos()
        first_run, max_sc, contador = True, 0, 0

        while True:
            seq_idx = self.random_seq()

            if first_run:
                probs, first_run = self.prob_each_seq(pos, seq_idx), False
            
            else: probs = self.prob_each_seq(pos, seq_idx, first=False)

            pos[seq_idx] = self.roulette_wheel(probs)[0]

            if self.score(pos) > max_sc:
                best_off, max_sc, contador = pos.copy(), self.score(pos), 0 

            else:
                contador += 1
                if contador >=50: break

        return best_off, max_sc


    def print_motif(self, positions: list[int]) -> None:
        """
        Prints the motif found at the given positions in the sequences.

        Parameters:
        ----------
        positions : list[int]
            A list of integers representing the positions of the motifs in the sequences.
            Each integer is the starting position of a motif in a sequence.
        """
        motifs = [self.seqs[i][p:p + self.w] for i, p in enumerate(positions)]
        for motif in motifs:
            print(f"{motif}")

if __name__ == "__main__":
    seqs = ['GTAAACAATATTTATAGC', 'AAAATTTACCTTAGAAGG', 'CCGTACTGTCAAGCGTGG', 'TGAGTAAACGACGTCCCA', 'TACTTAACACCCTGTCAA']
    position, score = Gibbs(seqs,8).gibbs_sampling()
    print(f"Positions: {position}",f"\nScore: {score}")
    print("\nMotif found:")
    Gibbs(seqs, 8).print_motif(position)

    print("\nMetricas de Codigo:")
    print("\nMetrica cyclomatic complexity:")
    print(subprocess.call(["radon","cc","Motifs/Gibbs_sampling.py", "-s"]))
    print("\nMetrica maintainability index:")
    print(subprocess.call(["radon","mi","Motifs/Gibbs_sampling.py", "-s"]))
    print("\nMetrica raw:")
    print(subprocess.call(["radon","raw","Motifs/Gibbs_sampling.py", "-s"]))
